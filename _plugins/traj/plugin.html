<plugin>
    <div class="mobile-header" style="font-weight:bold">Trajectory Plugin</div>
    <div id="main" class="plugin-content">
        <div id="desktop-title" class="title">Trajectory Plugin</div><br>

        <div id="selectlevels-h"  class="heading"><span id="selectlevels-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;Select Levels</div>
        <div id="selectlevels" style="margin-bottom:10px; display:none; margin-left:25px;"></div>

        <div id="selectmodels-h"  class="heading"><span id="selectmodels-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;Select Models</div>
        <div id="selectmodels" style="margin-bottom:10px; display:none; margin-left:25px;"></div>

        <div id="settings-h"  class="heading"><span id="settings-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;Settings</div>
        <div id="settings" style="margin-bottom:10px; display:none">
            <div id="setting-ascent"><span class="settings-fld">Ascent: <span id="asc-val"></span></span></div>
            <div id="setting-descent"><span class="settings-fld">Descent: <span id="des-val"></span></span></div>
            <div id="setting-setdur"><span class="settings-fld">Duration: <span id="setdur-val"></span></span></div>
            <div id="setting-maxdur"><span class="settings-fld">Max duration: <span id="maxdur-val"></span>h</span></div>
            <div id="setting-sample"><span class="settings-fld" style="width:150px">Sample (Level): <span id="sample-val"></span></span></div>
            <div id="setting-sampleAscDes"><span class="settings-fld" style="width:150px">Sample (Asc/Des): <span id="sampleAscDes-val"></span></span></div>
            <div id="setting-mrkrIntv"><span class="settings-fld" style="width:150px">Marker Intervals: <span id="mrkrIntv-val"></span></span></div>
        </div>

        <div id="airspaces-h" class="heading"><span id="airspaces-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;Airspaces</div>
        <div id="airspaces" style="margin-bottom:10px; position:relative; display:none; margin-left:25px;">
            <div id="aipdiv"></div>
        </div>

        <div id="selectcolors-h" class="heading"><span id="selectcolors-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;Select Colors</div>
        <div id="selectcolors" style="margin-bottom:10px; position:relative; display:none">
            <div id="col-content" style="display:inline-block">  </div>
            <div id="colpick" style="position:relative; display:inline-block; vertical-align:top;"></div>
        </div>

        <div id="about-h" class="heading"><span id="about-ar" style="pointer-events:none"></span>&nbsp;&nbsp;&nbsp;About</div>
        <div id="about" style="margin-bottom:10px; display:none">
            &nbsp;-&nbsp;Place the picker. <br>
            &nbsp;-&nbsp;Select levels. <br>
            &nbsp;-&nbsp;Select trajectory duration. <br>
            &nbsp;-&nbsp;Select Ascent and Descent speed (m/s). <br>
            &nbsp;-&nbsp;If Ascent or Descent is set at 0, ascent or descent phases will be ignored. <br>
            &nbsp;-&nbsp;Set start time with Windy slider.   <br>
            &nbsp;-&nbsp;Start!    <br>
            &nbsp;-&nbsp;Current sample interval is 15 minutes,  ascent and descent phases at 1 min.  <br>
            &nbsp;-&nbsp;Duration slider will show progress. <br>
            &nbsp;-&nbsp;You can create many trajectories.   <br>
            &nbsp;-&nbsp;The trajectory can also be calculated in reverse,  to find starting point. <br>
            &nbsp;-&nbsp;Clicking a trajectory will switch the map to the correct timestamp and level,  and the marker will show the info at that point. <br>
            &nbsp;-&nbsp;If the picker is closed,  the trajctory marker will be used if visible,  when clicking "start" <br>
            &nbsp;-&nbsp;PluginDataLoader is used,  will use the model selected (ECMWF, GFS or ICON).<br>
        </div>

        <div style="font-size:10px;margin-top:15px">Settings will be stored in localStorage on your browser.</div>
    </div>

<script>
    let version= "0.5.0";

   	import map from '@windy/map';
	import store from '@windy/store';
	import bcast from '@windy/broadcast';
    import picker from '@windy/picker';
    import $ from '@windy/$';
    import rs from '@windy/rootScope';
    import utils from '@windy/utils';
    import ib from './infobox.mjs';
    import pluginDataLoader from '@windy/pluginDataLoader'
    import metrics from '@windy/metrics';
    import favs from '@windy/favs';
    import rp from './rplannerWrapper.mjs';
    import asp from './airspaces.mjs';
    import pickerT from './pickerTools.mjs';

    const load = pluginDataLoader({
		key: 'tqBdvHJjtNrGq4TrFzt9D5NDz9fIZSC8'
		, plugin: 'windy-plugin-traj'
	});


    let trajplugin=this;
    let traj=[];
    let currentlvl;
    let ascent=localStorage.getItem("ascent");
    if (!ascent) ascent=0;
    let descent=localStorage.getItem("descent");
    if (!descent) descent=0;
    let durmin=localStorage.getItem("durmin");
    if (!durmin) durmin=0;
    let maxdur=localStorage.getItem("maxdur");
    if (!maxdur) maxdur=720;
    let menuOpen=JSON.parse(localStorage.getItem("menuOpen"));
    if (!menuOpen)
        menuOpen={selectlevels:false, selectmodels: false, about:false, airspaces:false, settings:false,selectcolors:false};
    let sample=Number(localStorage.getItem("sample"));
    if (!sample)sample=15;
    var sampleAscDes=Number(localStorage.getItem("sampleAscDes"));
    if (!sampleAscDes)sampleAscDes=1;

    let pntAlt,pntAltm;

    let reftime;
    let h1=60*60*1000;  let h3=3*h1;  let min1=60*1000;  let d1=24*60*60*1000;   let d6=6*24*60*60*1000;
    let mrkrIntv=localStorage.getItem("mrkrIntv");
    mrkrIntv=h1;

    //let ts;            //timestamp   no longer used
    let tn=Date.now(); //time now
    let startlvl, startmodel;
    let running=false;
    let backw=false;
    let metric_wind=store.get("metric_wind");
    let metric_dist=metricDist(metric_wind);
    let selectedPnt=false;
    store.on("metric_wind",w=>{
        metric_wind=w;
        metric_dist=metricDist(w);
    });

    let fvs=favs.getAll();
    let fvsDivs=[];
    let lvlsetbyplugin=false;

    let rplannerOptions={
        myPlugin:this.ident,
        helpText:"This is help text.",
        openPluginText:"Open Traj",
        left:401,
        interactive:false,
        pathsDisplay:"none",
        distanceDisplay:"none",
        dotOpacity:0.3
    };

    let fitBoundsFx=map.fitBounds;


    let pickerOpen=false;
    bcast.fire('rqstClose','picker');
    picker.on("pickerClosed",()=>{console.log("Picker closed");pickerOpen=false});
    picker.on("pickerOpened",()=>{console.log("Picker open");pickerOpen=true});
    bcast.on("pluginOpened",e=>{if (e=="picker") pickerOpen=true});

    function menuToggle(c){
        $("#"+c).style.display=menuOpen[c]?"block":"none";
        $("#"+c+"-ar").innerHTML=menuOpen[c]?"&#9661;":"&#9655;";
        if ($("#settings").style.display=="block") placeThumbs();
        localStorage.setItem("menuOpen",JSON.stringify(menuOpen));
    }
    setTimeout(()=>{for(let n in menuOpen)menuToggle(n)},500);
    let hdg=document.getElementsByClassName("heading");
    for (let i=0; i<hdg.length; i++){
        hdg[i].addEventListener("click",e=>{
            let n=e.target.id.slice(0,-2);
            menuOpen[n]=!menuOpen[n];
            menuToggle(n);
        });
    }

    function metricDist(mw){
        switch (mw){
            case "m/s":  case "km/h":  return "km";  break;
            case "mph":   return "mi";  break;
            default: return  "NM";
        }
    }

    let levels=store.get("availLevels");
    let selLvls;
    try{
        selLvls=JSON.parse(localStorage.getItem("selLvls"));
    } catch (e){console.log("error localStorage, load default values");}

    if (!selLvls  ||  selLvls[0].col.slice(0,2)=="rg")
    selLvls=[ {lvl: "surface", alt:30, altm:10,    sel: false,
                //col:"DarkRed"}
                //col:"rgba(205, 92, 92, 1)"}
                col: "#CD5C5C"}
        , {lvl: "1000h", alt:330, altm:100,  sel: false,
                //col: "DarkGreen"}
                //col:"rgba(255, 160, 122, 1) "}
                col:"#FFA07A"}
        , {lvl: "950h", alt:2000, altm: 600, sel: false,
                //col: "DarkYellow"}
                //col:"rgba(255, 0, 0, 1)"}
                col: "#FF0000"}
        , {lvl: "925h", alt:2500, altm: 750, sel: false,
                //col: "DarkBlue"}
                //col:"rgba(255, 192, 203, 1)   "}
                col:"#FFC0CB"}
        , {lvl: "900h", alt:3000, altm:900, sel: false,
                //col: "DarkMagenta"}
                //col:"rgba(255, 105, 180, 1) "}
                col:"#FF69B4"}
        , {lvl: "850h", alt:5000,  altm:1500, sel: false,
                //col: "DarkCyan"}
                //col:"rgba(255, 160, 122, 1)"}
                col:"#FFA07A"}
        , {lvl: "800h", alt:6400,  altm:2000, sel: false,
                //col: "Red"}
                //col:"rgba(255, 165, 0, 1)"}
                col:"#FFA500"}
        , {lvl: "700h", alt:10000, altm:3000, sel: false,
                //col: "Green"}
                //col:"rgba(255, 255, 0, 1)"}
                col:"#FFFF00"}
        , {lvl: "600h", alt:14000, altm:4200, sel: false,
                //col: "Yellow"}
                //col:"rgba(255, 228, 181, 1)"}
                col:"#FFE4B5"}
        , {lvl: "500h", alt:18000, altm:5500,sel: false,
                //col: "Blue"}
                //col:"rgba(255, 0, 255, 1)"}
                col:"#FF00FF"}
        , {lvl: "400h", alt:24000, altm:7000, sel: false,
                //col: "Magenta"}
                //col:"rgba(173, 255, 47, 1)"}
                col:"#ADFF2F"}
        , {lvl: "300h", alt:30000, altm:9000, sel: false,
                //col: "Cyan"}
                //col:"rgba(0, 255, 255, 1)"}
                col:"#00FFFF"}
        , {lvl: "200h", alt:39000, altm:11700, sel: false,
                //col: "LightGray"}
                //col:"rgba(135, 206, 250, 1)" }
                col:"#87CEFA"}
        , {lvl: "150h", alt:45000, altm:13500, sel: false,
                //col: "White"}
                //col:"rgba(255, 255, 255, 1)"}
                col:"#FFFFFF"}
    ];
    let selModels=JSON.parse(localStorage.getItem("selModels"));
    if(!selModels)selModels=[{m:"ecmwf",sel:true},{m:"gfs",sel:true},{m:"iconEu",sel:true}];

    ////message div
    let msgdiv=document.createElement("div");
    msgdiv.classList.add("msg-div");

    ////Box at bottom left
    ib(`<div style="box-sizing-border-box;  padding:5px 5px 3px 5px; display:inline-block; pointer-events:auto; border-radius:7px; background-color:rgba(0,0,0,0.5); border:  1px solid rgba(0,0,0,0.6); font-size:13px;">`

     /*
        +`<div id="select-levels" style="width:230px; font-size:12px; margin-bottom:8px;"><div style="margin-bottom:5px;font-size:13px">Select Levels</div></div>
            <div style="display:inline-block">
                <div style="margin:0px;position:relative; width:113px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                    <input id="asc_range" step="0.1" style="left:3px; height:20px; top:-1px; position:absolute;  width:calc(100% - 6px); z-index:999; opacity:0;" type="range"  max="8" >
                    <div id="thumb_asc" class="thumb"></div>
                </div>
                <div  style="width:113px;   ">Ascent: <span id="asc_span"></span></div>
            </div>
            <div style="display:inline-block">
                <div style="margin:0px;position:relative;  width:113px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                    <input id="des_range"  step="0.1" style="left:3px; height:20px; top:-1px; position:absolute;  width:107px; z-index:999; opacity:0;" type="range"  max="8" >
                    <div id="thumb_des" class="thumb"></div>
                </div>
                <div  style="width:113px;   ">Descent: <span id="des_span"></span></div>
            </div>`
*/

        +`   <div style="position:relative; width:200px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                <input id="dur_range" style="left:3px; height:20px; top:-1px; position:absolute;  width:calc(100% - 6px); z-index:999; opacity:0;" type="range" step="${sample}" max="${maxdur}" >
                <div id="progress-thumb" class="thumb" style="opacity:0" ></div>
            </div>

            <div  style="  width:220px; ">Progress: <span id="duration"></span>&nbsp;&nbsp;<span style="font-size:9px">Running <span  id="traj-direction">${backw?"backward - find start":"forward - find end"}</span></span></div>

            <div id="open-left-pane" class="start-buttons">
                Menu
            </div
            ><div id="save-gpx" class="start-buttons">
                Save
            </div
            ><div id="clear-trajs" class="start-buttons">
                Clear
            </div
            ><div id="backw" class="start-buttons" >
                ${backw?"Forw":"Back"}
            </div
            ><div id="start-IP" class="start-buttons">
                Start
            </div>

        </div>
        <div id="display-fav-div"  class="iconfont">k</div>
        <div id="fav-div" style="display:none;max-height: 200px; overflow-y: auto;"><span style="font-weight:bold">Click to find fav:</span><br></div>
        `,
        "open-left-pane", "windy-plugin-traj", this
    );

    function RangeEl(w,mx,mn,stp,outdiv,iv2rv=false,rv2iv=false,rv2st=false,cb=false){
        this.wrap=document.createElement("div");
        this.wrap.classList.add("rangeWrap");
        this.wrap.style.width=w;
        this.input=document.createElement("input");
        this.input.type="range";
        this.input.max=mx;
        this.input.min=mn;
        this.input.step=stp;
        this.input.classList.add("rangeInput");
        this.thumb=document.createElement("div");
        this.thumb.classList.add("thumb");
        this.wrap.appendChild(this.input);
        this.wrap.appendChild(this.thumb);
        this.outdiv=outdiv;

        this.appendTo= function(e){
            //console.log(this);
            e.appendChild(this.wrap)
        };
        this.setThumb=function(v){
            let offsetw=this.wrap.offsetWidth;
            //console.log("VALUE",v,"OFFSETW",offsetw);
            this.thumb.style.left=((offsetw-20)*v/this.input.max)+"px";
        }
        this.calcRangeVal=function(iv){
            let rv=iv2rv?iv2rv(iv):iv;
            this.rangeValue=rv;
            this.outdiv.innerHTML=rv2st?rv2st(rv):rv;
            if (cb) cb(rv);
        }
        this.calcInputVal=function(rv){//and place thumb
            this.outdiv.innerHTML=rv2st?rv2st(rv):rv;
            let iv=rv2iv?rv2iv(rv):rv;
            //console.log("RV",rv,"IV",iv);
            //console.log(iv.indexOf(rv));
            this.input.value=iv;
            this.setThumb(iv);
        }
        this.input.addEventListener("input",e=>{
            this.setThumb(e.target.value);
            this.calcRangeVal(e.target.value);
        });
        this.addLabels=function(ar){
            for (let i=0, l=ar.length;i<l;i++){
                let e=document.createElement("div");
                e.classList.add("rangeLabels");
                Object.assign(e.style,{"left":(-6+i*12/l)+"px" , "width":"calc("+(100/l)+"%)"});
                e.innerHTML=ar[i];
                this.wrap.appendChild(e);
            }
        }
    }

    let maxDurRange=new RangeEl("calc(100% - 130px)",240,0,2, $("#maxdur-val"),
        v=>v,v=>v,v=>v,
        v=>{
            maxdur=v*60;
            setDurRange.input.max=maxdur;
            if (durmin>maxdur)durmin=maxdur;
            setDurRange.calcInputVal(durmin);
            localStorage.setItem("durmin",durmin);
            localStorage.setItem("maxdur",maxdur);
        }
    );
    maxDurRange.appendTo($("#setting-maxdur"));

    let setDurRange=new RangeEl("calc(100% - 130px)",maxdur,0,sample, $("#setdur-val"),
        v=>v, v=>v, rv=>('0'+Math.floor(rv/60)).slice((rv/60)>99?-3:-2)+':'+('0'+ rv%60).slice(-2),
        v=>{
            durmin=v;
            localStorage.setItem("durmin",durmin);
        }
    );
    setDurRange.appendTo($("#setting-setdur"));

    let ascRange=new RangeEl("calc(100% - 130px)",8,0,0.1, $("#asc-val"),
        v=>v, v=>v, rv=>Number(rv)?(rv+ "m/s"):"None",
        v=>{
            ascent=v;
            localStorage.setItem("ascent",ascent);
        }
    );
    ascRange.appendTo($("#setting-ascent"));

    let decRange=new RangeEl("calc(100% - 130px)",8,0,0.1, $("#des-val"),
        v=>v, v=>v, rv=>Number(rv)?(rv+ "m/s"):"None",
        v=>{
            descent=v;
            localStorage.setItem("descent",descent);
        }
    );
    decRange.appendTo($("#setting-descent"));

    let sampleOpts=[5,10,15,20,30,60,180];
    let sampleRange=new RangeEl("calc(100% - 160px)",6,0,1, $("#sample-val"),
        v=>sampleOpts[v], v=>sampleOpts.indexOf(v), rv=>(rv+ "min"),
        v=>{
            sample=v;
            localStorage.setItem("sample",sample);
            setDurRange.input.step=sample;
        }
    );
    sampleRange.appendTo($("#setting-sample"));
    sampleRange.addLabels(sampleOpts);

    let sampleOptsAD=[0.5,1,2,3,5,10,15];
    let sampleAscDesRange=new RangeEl("calc(100% - 160px)",6,0,1, $("#sampleAscDes-val"),
        v=>sampleOptsAD[v], v=>sampleOptsAD.indexOf(v), rv=>(rv+ "min"),
        v=>{
            sampleAscDes=v;
            localStorage.setItem("sampleAscDes",sampleAscDes);
        }
    );
    sampleAscDesRange.appendTo($("#setting-sampleAscDes"));
    sampleAscDesRange.addLabels(sampleOptsAD);

    let mrkrIntervals=[0,5*min1,10*min1, 15*min1,20*min1,30*min1,60*min1,180*min1];
    let mrkrIntvRange=new RangeEl("calc(100% - 160px)",7,0,1, $("#mrkrIntv-val"),
        v=>mrkrIntervals[v], v=>mrkrIntervals.indexOf(v), rv=>(Math.round(rv/min1)+ "min"),
        v=>{
            mrkrIntv=v;
            localStorage.setItem("mrkrIntv",mrkrIntv);
            recalcTimeMrkrs(mrkrIntv, false);
        }
    );
    mrkrIntvRange.appendTo($("#setting-mrkrIntv"));
    mrkrIntvRange.addLabels(mrkrIntervals.map(e=>Math.round(e/min1)));
    mrkrIntvRange.input.addEventListener("change",()=>{
        if (ghostmrkr.k>=0){
            let k=ghostmrkr.k;
            let s=traj[k].sample;
            for (var i=Number(mrkrIntvRange.input.value);  mrkrIntervals[i] % (traj[k].sample*min1) && i<mrkrIntervals.length; i++);

            mrkrIntv=mrkrIntervals[i];
            mrkrIntvRange.calcInputVal(mrkrIntv);
            recalcTimeMrkrs(mrkrIntv, false);

            if (traj[k].mrkrIntv!=mrkrIntv){
                traj[k].mrkrIntv=mrkrIntv;
                if (rp.isOpen ){
                    map.fitBounds=()=>{};
                    setTimeout(()=>map.fitBounds=fitBoundsFx, 1000);
                    openRPlanner();
                }
            }
        }

    });


    function placeThumbs(){
        maxDurRange.calcInputVal(Math.round(maxdur/60));
        setDurRange.calcInputVal(durmin);
        ascRange.calcInputVal(ascent);
        decRange.calcInputVal(descent);
        sampleRange.calcInputVal(sample);
        sampleAscDesRange.calcInputVal(sampleAscDes);
        mrkrIntvRange.calcInputVal(mrkrIntv);
    }

    /*function setDes(v){
        $('#thumb_des').style.left=93*v/8+'px';
        descent=v;
        if (descent==0) $('#des_span').innerHTML="None";
        else $('#des_span').innerHTML=descent+" m/s";
        localStorage.setItem("descent",descent);
    }*/
    //$("#dur_range").addEventListener("input",e=>setDur(e.target.value));
    //$("#asc_range").addEventListener("input",e=>setAsc(e.target.value));
    //$("#des_range").addEventListener("input",e=>setDes(e.target.value));
    //setAsc(ascent);  setDes(descent);


    function showMsg(m){
        msgdiv.innerHTML=m;
        document.getElementById("map-container").appendChild(msgdiv);
        setTimeout(()=>msgdiv.remove(), 2000);
    }
    $("#start-IP").addEventListener("click",()=>{
        startmodel=store.get("product");
        let startpos=pickerOpen?picker.getParams():(selectedPnt?selectedPnt:false);
        if (!startpos){
            let c;
            if (W.detail.hasOwnProperty("loadedData")){
                c=W.detail.loadedData.header;
                console.log(c);
            }
        }
        if (startpos && !running){// && (startmodel=="ecmwf" ||  startmodel=="gfs" || startmodel=="iconEu"))  {
            if (backw && (store.get("timestamp")+h1/2)<tn+durmin*min1){
                showMsg(`Backward trajectory<br>Move time forward.`);
            } else {
                drawTraj(startpos);
                running=true;
                $("#start-IP").innerHTML="Stop";
            }
        }  else if (running){
            running=false;
        }  else if (!startpos) {
            showMsg(`Place Picker`);
        }  else {
            showMsg(`Model (${startmodel}) not supported`);
        }
    });
    $("#clear-trajs").addEventListener("click",()=>{
        traj.forEach(e=>e.seg.forEach(l=>{
            l.line.remove();
            l.ghostline.remove();
            l.pnts.forEach(m=>{if(m.mrkr)m.mrkr.remove()});
        }));
        traj=[];
    });
    $("#backw").addEventListener("click",e=>{           ////allow backward traj
        backw=!backw;
        let tmp=ascent; ascent=descent; descent=tmp;
        e.target.innerHTML=backw?"Forw":"Back";
        $("#traj-direction").innerHTML=backw?    "<span style='font-weight:bold'>backward</span> - find start":    "<span style='font-weight:bold'>forward</span> - find end";
    });
    $("#save-gpx").addEventListener("click",()=>{
        saveGPX();
    });
    $("#display-fav-div").addEventListener("click",()=>{
        if ($("#fav-div").style.display=="none"){
            $("#fav-div").style.display="inline-block";
            $("#display-fav-div").style.opacity=1;
        }  else {
            $("#fav-div").style.display="none";
            $("#display-fav-div").style.opacity=0.4;
        }
    });

    let openRplanBut=document.createElement("div");
    openRplanBut.classList.add("start-buttons");
    openRplanBut.style.width="auto";
    Object.assign(openRplanBut.style,{"position":"relative","z-index":2000,"left":"5px","top":"-25px","border-radius":"3px","background-color":"rgba(0,0,0,0.7)", "padding":"0px 3px 0px 3px"});
    openRplanBut.innerHTML="Route Planner";
    openRplanBut.addEventListener("click",e=>{
        e.stopPropagation();
        if (rp.isOpen){
            rp.close();
        }   else {
            openRPlanner();
            openRplanBut.innerHTML="Close Route Planner";
        }

    });



    function openRPlanner(){//open rplanner for selected traj (ghostmrkr.k)
        if (typeof ghostmrkr.k !=="undefined"){
            let k=ghostmrkr.k;
            let rt=[];
            let i,il,j,jl;
            let altAr=[];
            for (i=0,il=traj[k].seg.length;i<il;i++){
                let sg=traj[k].seg[i];
                for (j=0,jl=sg.pnts.length;j<jl;j++){
                    let p=sg.pnts[j];
                    if (p.mrkr || (i==0 && j==0) || (i==il-1 && j==jl-1))
                        rt.push({coords:{lat:p.lat,lng:p.lng},altit:p.altm});
                    altAr.push({x:p.dist/traj[k].dist,altit:(p.altm>traj[k].altm?traj[k].altm:p.altm)});
                }
            }
            rplannerOptions.altAr=altAr;


            //console.log(rt);
            let res=rp.loadRP(
                rt,rplannerOptions,
                placeInfomrkr,
                ()=>{openRplanBut.innerHTML="Route Planner"}
            )

            if (res !== true)
                showMsg(res);
        }
    }

    this.onopen=()=> {rp.setLeft(401)};
    this.onclose=()=>{rp.setLeft(0)};

    if (rs.isMobile)$("#desktop-title").style.display="none";
    if (rs.isTablet){$("#logo").style.left="100%"; $("#logo").style.marginLeft="-150px";}

    selModels.forEach((e,i)=>{
        e.div=document.createElement("div");
        e.div.innerHTML=e.m;
        e.div.style.display="inline-block";   e.div.style.padding="1px"; e.div.style.borderRadius="3px"; e.div.style.cursor="pointer";
        if (e.sel){
            e.div.style.opacity=1;
            e.div.style.color="yellow";
        } else {
            e.div.style.opacity=0.25;
            e.div.style.color="white";
        }
        e.div.addEventListener("click",el=>{
            if(e.sel){
                e.div.style.opacity=0.25;
                e.sel=false;
            } else {
                if (store.get("visibleProducts").indexOf(e.m)!=-1){
                    e.div.style.opacity=1;
                    e.div.style.color="yellow";
                    e.sel=true;
                } else {
                    e.div.innerHTML=e.m+" is unavailable here";
                    setTimeout(()=>e.div.innerHTML=e.m,3000);
                    e.div.style.color="white";
                }
            }
            localStorage.setItem("selModels",JSON.stringify(selModels));
        });
        e.div.addEventListener("mouseover",el=>{e.div.style.backgroundColor="black"});
        e.div.addEventListener("mouseout",el=>{e.div.style.backgroundColor="transparent"});
        $("#selectmodels").appendChild(e.div);
        let br=document.createElement("br");
        $("#selectmodels").appendChild(br);
    })

    selLvls.forEach((e,i)=>{
        e.div=document.createElement("div");
        e.div.innerHTML=`<span class="lvlspan">${e.lvl}</span><span class="lvlspan">${(e.alt<10000?(e.alt+"ft"):(e.alt/100+"FL"))}</span><span class="lvlspan" style="width:auto">${e.altm}m</span>`;
        e.div.style.display="inline-block";  e.div.style.padding="1px"; e.div.style.borderRadius="3px"; e.div.style.cursor="pointer";
        if (e.sel){
            e.div.style.opacity=1; e.div.style.color=e.col;
        } else {
            e.div.style.opacity=0.25; e.div.style.color="white";
        }
        e.div.addEventListener("click",el=>{
            if(e.sel){
                e.div.style.opacity=0.25;
                e.sel=false;
                e.div.style.color="white";
            } else {
                e.div.style.opacity=1;
                e.div.style.color=e.col;
                e.sel=true;
            }
            localStorage.setItem("selLvls",JSON.stringify(selLvls));
        });
        e.div.addEventListener("mouseover",el=>{e.div.style.backgroundColor="black"});
        e.div.addEventListener("mouseout",el=>{e.div.style.backgroundColor="transparent"});

        let lbl=document.createElement("div");  lbl.innerHTML="<span style='display:inline-block;width:50px'>"+e.lvl+"</span>";
        $("#col-content").appendChild(lbl);
        e.input=document.createElement("input");
        e.input.type="text";
        e.input.value=e.col;
        e.input.dataset.i=i;
        e.input.classList.add("trajColor");
        lbl.appendChild(e.input);
        e.input.onfocus=()=>{
            setTimeout(()=>{
                $("#colpick").firstElementChild.style.transition="all 0.3s";
                $("#colpick").firstElementChild.style.left="3px";
                $("#colpick").firstElementChild.style.top="25px";
            },100);
        }
        e.input.onkeydown=e=>e.stopPropagation();
        e.input.onchange=e=>{e.target.blur();e.target.focus()}
        $("#selectlevels").appendChild(e.div);

        let br=document.createElement("br");
        $("#selectlevels").appendChild(br);

    })

    ////favourites
    for (let f in fvs){
        let d=document.createElement("div");
        d.innerHTML=fvs[f].name;
        d.style.padding="3px";
        d.style.cursor="pointer";
        d.addEventListener("click",e=>{
            fvsDivs.forEach(dd=>dd.style.fontWeight="normal");
            d.style.fontWeight="bold";
            map.setView(fvs[f]);
            setTimeout(()=>bcast.fire('rqstOpen','picker',fvs[f]),2000);
        })
        fvsDivs.push(d);
        $("#fav-div").appendChild(d);
    }

    ////color picker
    function cb(col,b,c){
        let i=c.input.dataset.i;
        selLvls[i].col=c.input.value;
        if(selLvls[i].sel) selLvls[i].div.style.color=selLvls[i].col;
        c.input.style.color=col.alpha<0.4?"black":(col.RGBLuminance<0.3?"white":"black");
        localStorage.setItem("selLvls",JSON.stringify(selLvls));
    }

    setTimeout(()=>{
        window.jsColorPicker("input.trajColor",{
            customBG:"#222",
            readOnly:false,
            size:1,
            appendTo: $("#colpick"),
            init:function(o,e){
                o.style.backgroundColor=o.value,
                o.style.color=e.alpha<0.4?"black":(e.RGBLuminance<0.3?"white":"black");
            },
            displayCallback:cb
        });
    },500);

    ////other settings:


    ////grab reftime
    function getRefTime(model){
        let cntr=map.getCenter();   cntr.lon=cntr.lng;    cntr.model=model;
        load("forecast",cntr).then(data=>{
            reftime=new Date(data.data.header.refTime).getTime();
            return reftime;
        });
    }
    startmodel=store.get("product");    getRefTime(startmodel);

    //function time2path(t){            ////no longer using the path
    //    hrsInt=(startmodel=="ecmwf" && t-reftime>d6)?6:3;
    //    let tmshift=new Date(t+hrsInt*30*60*1000);
    //    return tmshift.getUTCFullYear()+"/"+("0"+(tmshift.getUTCMonth()+1)).slice(-2)+"/"+("0"+tmshift.getUTCDate()).slice(-2)+"/"+("0"+Math.floor(tmshift.getUTCHours()/hrsInt)*hrsInt).slice(-2);
    //}

    function time2index(t){
        let i= Math.floor((t-reftime-h3/2)/h3);
        if (startmodel=="ecmwf"  &&  i>47) i=47+Math.floor((i-46)/2);
        return i;
    }
    function time2midtime(t){
        let h=(startmodel=="ecmwf" && t-reftime>d6+h3/2)?h3*2:h3;
        return Math.floor(((t-reftime)+h/2)/h)*h;
    }
    function recalcTimeMrkrs(intv,all=false){ //intv in ms,    apply to all = true   or selected = false
        traj.forEach(tr=>{
            //console.log(ghostmrkr.k,tr.k);
            if (all || ghostmrkr.k==tr.k) tr.seg.forEach(sg=>sg.pnts.forEach(pnt=>{
                if (pnt.mrkr)pnt.mrkr.remove();
                pnt.mrkr=(intv==0 || pnt.t%intv==0)? L.circleMarker(pnt,{radius:1, color:"black", weight:4,  opacity:0.8, interactive:false}).addTo(map) : false;
            }))
        });
    }

    ////highlight time segment   (3 or 6 hours if ecmwf>6 days after reftime)
    store.on("timestamp",e=>{
            let midtime=time2midtime(e);
            traj.forEach(e=>e.seg.forEach(l=>{
                if (l.midtime==midtime)l.line.setStyle({weight:4});
                else l.line.setStyle({weight:2});
            }));
    });

    store.on("level",lvl=>{
        if(lvl=="100m")lvl="1000h"; else if (lvl=="250h")lvl="300h";
        if (lvlsetbyplugin){
            lvlsetbyplugin=false;
        } else {
            selLvls.forEach(e=>{
                e.div.style.fontWeight= e.lvl==lvl?"bold":"normal";
            });

        }
        currentlvl=lvl;
        traj.forEach(e=>e.seg.forEach(l=>{
            if (l.lvl==lvl)l.line.setStyle({opacity:1});
            else l.line.setStyle({opacity:0.4});
        }));
    });

    function deSelectTraj(){
        console.log(map._events.click );
        console.log("MAP CLICKED");
        if (!rp.isOpen){
            $("#mrkr").style.display="none";
            $("#active-mrkr").style.display="none";
            selectedPnt=false;
            ghostmrkr.k=-1;
        }
    }
    map.on("click",deSelectTraj);

    function drawTraj(cstart,startt=false,lvli=-1,mdli=-1){
        let c=cstart;
        pntAltm=-9999;
        if (!startt){
            startt= Math.round((store.get("timestamp"))/(60*min1))*60*min1;
            startlvl=store.get("level");
            startmodel=store.get("product");
        }
        $('#progress-thumb').style.opacity=1;
        let nextLvl=(lvli)=>{
            for (lvli++ ;lvli<selLvls.length&&!selLvls[lvli].sel ;lvli++);
            return lvli<selLvls.length?lvli:-1;
        }
        if (lvli<0){
            lvli=nextLvl(lvli);
            if (lvli<0) return;
        }
        let nextMdl=(mdli)=>{
            for (mdli++ ;mdli<selModels.length&&!selModels[mdli].sel ;mdli++);
            return mdli<selModels.length?mdli:-1;
        }
        if (mdli<0){
            mdli=nextMdl(mdli);
            if (mdli<0) return;
        }
        let lvl=selLvls[lvli].lvl;
        let col=selLvls[lvli].col;

        store.set("level",lvl=="1000h"?(startmodel=="iconEu"?"surface":"100m"):lvl);
        store.set("product",selModels[mdli].m);
        traj.forEach(e=>e.seg.forEach(l=>l.line.setStyle({opacity:0.4})))

        let k=traj.push({
            starttimeStr:new Date(startt).toISOString().slice(0,-5)+"Z",
            dist:0,
            ete:0,
            lvl:lvl,
            lvli:lvli,
            alt:selLvls[lvli].alt,
            altm:selLvls[lvli].altm,
            model:selModels[mdli].m,
            ascent: ascent,
            descent: descent,
            sample: sample,
            sampleAscDes: sampleAscDes,
            calcBackward: backw,
            seg:[],
            k:traj.length,  //k= index
            mrkrIntv:mrkrIntv
        })-1;

        let previ=-99;
        let j=-1;
        let n=0;
        let descending=false;

        let fetchData=(c,t,lvl)=>{
            store.set("timestamp",t);

            //console.log(selModels[mdli].m);
            let fetchPoint=c=>{
                c.model=selModels[mdli].m;
                load('airData',c).then(data=>{
                    //console.log(data);
                    reftime=new Date(data.data.header.refTime).getTime();

                    let i=time2index(t);    //i refers to index in data array,  3 hourly intervals
                                            //the reftime may change and consequently index value may change.

                    if (i!=previ){  //add segment with polyline
                        j++;
                        traj[k].seg[j]={
                            line:L.polyline([c], {color: col, weight:2, opacity:1, interactive:false, smoothFactor:0.5}).addTo(map),
                            ghostline:L.polyline([c], {color: "white", opacity:0, weight:15, smoothFactor:0.1, interactive:true, bubblingMouseEvents:false}).addTo(map),
                            lvl:lvl, model:selModels[mdli].m, alt:selLvls[lvli].alt, t:t, midtime:time2midtime(t),  j:j, k:k,  pnts:[]
                        };
                        let ll=traj[k].seg[j];
                        ll.ghostline.on("click",ev=>{
                            ghostmrkr.k=k; //ghostmrkr.k is the currently selected route
                            let nearestPnt=placeInfomrkr(ev.latlng,true);
                            store.set("timestamp",nearestPnt.t);
                            store.set("product",ll.model);

                            ghostmrkr.setLatLng(nearestPnt);

                            lvlsetbyplugin=true;
                            store.set("level",ll.lvl=="1000h"?(ll.model=="iconEu"?"surface":"100m"):ll.lvl);
                            selLvls.forEach(e=>{
                                if(ll.lvl==e.lvl)e.div.style.fontWeight="bold"; else e.div.style.fontWeight="normal";
                            });
                            traj.forEach(e=>e.seg.forEach(l=>{
                                if (ll.k==l.k){
                                    if (ll.j==l.j) l.line.setStyle({weight:4, opacity:1});
                                    else l.line.setStyle({weight:2, opacity:0.9});
                                }else l.line.setStyle({weight:2,opacity:0.4});
                            }));

                            if (rp.isOpen){
                                openRPlanner();
                            }

                            console.log(traj[k].mrkrIntv);
                            mrkrIntvRange.calcInputVal(traj[k].mrkrIntv);
                        });
                        previ=i;
                    }


                    let endTraj=false;
                    let smpl=sampleAscDes;
                    let pntElev=data.data.header.elevation;

                    //look for phase and determine next alt.  With start of traj pntAltm=-9999
                    if (traj[k].lvl=="surface"){
                        pntAltm=pntElev;
                        smpl=sample;
                        if (t>startt+durmin*min1 || (backw && t<startt-durmin*min1)) endTraj=true;               ////allow backward traj
                    }  else {
                        if (pntAltm==-9999){ //start
                            if (ascent==0 || pntElev>=traj[k].altm){
                                smpl=sample;
                                pntAltm=(pntElev>traj[k].altm)?pntElev:traj[k].altm;
                            } else {
                                pntAltm=pntElev;
                            }
                        } else if (descending || (t>=startt+durmin*min1 || (backw && t<=startt-durmin*min1))){    // duration hit,  start descent ////allow backward traj
                            if (descent==0 || (pntAltm<=pntElev+10)) endTraj=true;  //stop if BGL or none descent selected
                            else {
                                if (descending) pntAltm-=descent*smpl*60;
                                else descending=true;
                            }
                        } else if (pntAltm<traj[k].altm){     //still rising.
                            pntAltm+=ascent*smpl*60;
                            if (pntAltm>=traj[k].altm){       //now  altitude reached
                                pntAltm=traj[k].altm;
                                smpl=backw?(t/min1)%sample : (sample-((t/min1)%sample)); //find next timepoint where (time in min % sample)==0.  Makes it easier to make hour markers.
                            }
                        } else{
                            smpl=sample;
                            if (pntElev>traj[k].altm) pntAltm=pntElev;
                        }
                    }

                    //console.log("Alt(m):",pntAltm, "Elev",pntElev);

                    traj[k].seg[j].pnts.push({
                            lat:c.lat,lng:c.lon,
                            t:t,
                            tStr: new Date(t).toISOString().slice(0,-5)+"Z",
                            elev:pntElev,
                            alt:pntAlt,
                            altm:pntAltm,
                            //lvl:w.nearestlvl,
                            sample:smpl,
                             dist:traj[k].dist
                    });
                    ////hour markers
                    if (t%mrkrIntv==0){
                            let tm=t;
                            traj[k].seg[j].pnts[traj[k].seg[j].pnts.length-1].mrkr=
                                 L.circleMarker(c,{radius:1, color:"black", weight:4,  opacity:0.8, interactive:false})
                                    .addTo(map)
                    }

                    if (!endTraj) {
                        n+=smpl;
                        let tpos=180*n/durmin; if (tpos>180)tpos=180;
                        $('#progress-thumb').style.left= (backw?180-tpos:tpos)+"px";

                        let getWind=(lvli,i)=>{    //let o=utils.wind2obj([u,v,0]);  utils of windy rounds to 10,  thus do not use
                                let u=data.data.data["wind_u-"+selLvls[lvli].lvl][i];
                                let v=data.data.data["wind_v-"+selLvls[lvli].lvl][i];
                                return{
                                    wind:Math.sqrt(u*u+v*v),
                                    dirto:(Math.floor(180*Math.atan2(u,v)/Math.PI)+360)%360
                                }
                        }

                        let topi,btmi, vrtio;
                        if (pntAltm>pntElev){
                            for (topi=1; topi<selLvls.length-1 && selLvls[topi].altm<=pntAltm; topi++);
                            let top=selLvls[topi].altm;
                            btmi=topi-1;
                            let btm=selLvls[btmi].altm;
                            if (selLvls[btmi].altm<pntElev){btmi=0; btm=pntElev;}
                            vrtio= (pntAltm-btm)/(top-btm);
                            if (vrtio>=1){btmi=topi; vrtio=0;} //if the pntAltm>topmost level,  then make the topmost index btmi and vrtio 0,  so correctly handled by verticalIP.
                        } else {
                            btmi=lvli;vrtio=0;
                        }

                        ////vertical linear interpolation on altitude in meter.  pressure  better???
                        let verticalIP=(vrtio,btmi,topi,i)=>{
                            if (vrtio==0 || typeof topi==="undefined"){
                                let w=getWind(btmi,i);
                                //console.log(w);
                                w.nearestlvl=selLvls[btmi].lvl;
                                return w;
                            } else {
                                let wb=getWind(btmi,i);
                                let wt=getWind(topi,i);
                                return{
                                    wind: wb.wind+(wt.wind-wb.wind)*vrtio,
                                    dirto: wb.dirto+(wt.dirto-wb.dirto)*vrtio,
                                    nearestlvl:selLvls[vrtio<0.5?btmi:topi].lvl
                                }
                            }
                        }
                        let w1=verticalIP(vrtio,btmi,topi,i);

                        ///interpolate time
                        let w,w2={};
                        let midt=data.data.data.hours[i];
                        let deltat=t-midt;
                        if ((deltat<=0 && i>0)|| (deltat>=0 && i<data.data.data.hours.length-1)){
                            let i2=deltat<0?i-1:i+1;
                            w2=verticalIP(vrtio,btmi,topi,i2);
                            //console.log("wind1:",w1.wind.toFixed(2),w1.dirto);console.log( "wind2:",w2.wind.toFixed(2),w2.dirto);
                            let trtio=Math.abs(deltat/(data.data.data.hours[i]-data.data.data.hours[i2]));
                            //console.log(trtio);
                            let deltadir=(w2.dirto-w1.dirto);
                            if (deltadir>180)deltadir=deltadir-360; else if (deltadir<-180)deltadir=deltadir+360;
                            w={wind: w1.wind+(w2.wind-w1.wind)*trtio ,dirto: ((w1.dirto+deltadir*trtio)+360)%360 ,nearestlvl:w1.nearestlvl}
                            //console.log("IP:",w.wind.toFixed(2),Math.round(w.dirto));
                        }  else {
                            w=w1;
                        }

                        let dirfrom=(w.dirto+180)%360;
                        let d=smpl*60*w.wind;



                         /////////calculate next point,  thx to Chris Veness (github)
                        var ad=d/6371000;//angular distance
                        var rad=Math.PI/180;
                        var brng=(backw?dirfrom:w.dirto)*rad;           ////allow backward traj
                        var lat1=c.lat*rad;
                        var lon1=c.lon*rad;
                        var lat2 = Math.asin(Math.sin(lat1)*Math.cos(ad) + Math.cos(lat1)*Math.sin(ad)*Math.cos(brng))   ;
                        var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(ad)*Math.cos(lat1), Math.cos(ad)-Math.sin(lat1)*Math.sin(lat2))   ;
                        lat2/=rad; lon2/=rad;
                        ///////////

                        traj[k].seg[j].line.addLatLng([lat2,lon2]);
                        traj[k].seg[j].ghostline.addLatLng([lat2,lon2]);

                        Object.assign(traj[k].seg[j].pnts[traj[k].seg[j].pnts.length-1],{
                            d:d,
                            wind:w.wind,
                            dir:Math.round(dirfrom),
                            nearestlvl:w.nearestlvl
                        });

                        traj[k].dist+=d;
                        traj[k].ete+=smpl*min1;
                        if(!traj[k].update) traj[k].update=data.data.header.update;

                        t+=smpl*min1 * (backw?-1:1);              ////allow backward traj
                        if (t>reftime+d1*10 || (t>reftime+d1*5 && selModels[mdli].m=="iconEu") || t<reftime+(h3/2)) {
                            endTraj=true;
                        }
                    }

                    if (endTraj || !running){
                        store.set("timestamp",startt);
                        $('#progress-thumb').style.opacity=0;
                        lvli=nextLvl(lvli);
                        if (lvli>=0 && running){
                            drawTraj(cstart,startt,lvli,mdli);
                        }  else {
                            mdli=nextMdl(mdli);
                            if (mdli>=0 && running) {
                                //lvli=nextLvl(-1);
                                drawTraj(cstart,startt,-1,mdli);
                            } else {
                                running=false;
                                $("#start-IP").innerHTML="Start";
                                console.log("This is the array of polylines and other properties:",traj);
                                store.set("level",startlvl);
                                store.set("product",startmodel);
                            }
                        }
                    } else setTimeout(fetchData,340,{lat:lat2,lon:lon2},t,lvl);
                }).catch(er=>{
                    console.log("usually  blocked by server CORS error - too busy???",   er);  /////usually  blocked by server CORS error - too busy???
                    if (er==0){
                        msgdiv.innerHTML=`Server not responding... trying...`;
                        document.getElementById("map-container").appendChild(msgdiv);
                        setTimeout(()=>msgdiv.remove(), 2000);
                    }
                    setTimeout(fetchPoint,3000,c);
                });
            }
            fetchPoint(c);
        }
        if(lvl){
            fetchData(c,startt,lvl);
        }
    }

///////Info marker
    let infoicon=L.divIcon({html:
        `<div id="mrkr" style="display:none; width:120px; outline-style:none;position:absolute;  font-family:arial; color:white;  text-shadow: 1px 1px 1px rgba(0,0,0,0.4); background-color:transparent; white-space:nowrap;">
            <div id="close-info-mrkr"  class="closing-x" style="display:block; margin:3px; font-size:15px; top:0px; right:0px;"></div>`+
            `<div style="display:block; position:absolute; left:-15px; top:0px; width:30px; height:140px;">
                <div style="position:absolute;left:15px;top:3px;border-left:2px solid rgba(0,0,0,0.8); height:115px;"></div>
                <div style="display:none; position:absolute; left:12px; top:calc(120.5px); background-color:white; width:8px; height:8px; border-radius:4px;"></div>
            </div>`+
            //`<div id="posname" class="picker-transparent"  style="position:absolute; top:-20px; left:0px; transform:translateX(-50%); font-weight:bold; "></div>`+
            `<div id="mrkrLeft" style="pointer-events: none; position:absolute; font-size:11px; line-height:110%;  top:0px;  position:absolute; padding:3px;  border-radius:5px 0px 0px 5px;  right:120px; opacity:1; background-color:rgba(0,0,0,0.7);">  </div>`+
            `<div id="mrkrRight" style="padding:3px; padding-bottom:25px; pointer-events: none; line-height:110%; width:100%; font-size:11px; position:relative;  border-radius:0px 5px 5px 0px;  left:0px; opacity:1; background-color:rgba(0,0,0,0.7);"></div>
        </div>`
    ,iconAnchor:[0,125]});
    let infomrkr = L.marker([0,0],{icon:infoicon, interactive:true, bubblingMouseEvents:false, opacity:1,  zIndexOffset:4700});
    infomrkr.addTo(map);
    infomrkr._icon.style.outlineStyle="none";
    L.DomEvent.on( $('#close-info-mrkr'), 'click', e=>{
        //use Leaflet addListener and not usual addEventListener to allow stop propagtion of the click, which will then open the picker
        L.DomEvent.stopPropagation(e);
        //infomrkr.setOpacity(0);   Do not use setOpacity,  mrkr hidden but still clickable
        $("#mrkr").style.display="none";
        $("#active-mrkr").style.display="none";
        selectedPnt=false;
    });
    $("#mrkr").appendChild(openRplanBut);

    let amicon=L.divIcon({
            html:"<div id='active-mrkr' style='position:absolute;width:12px;height:12px;border-radius:5px;border:1px solid white'></div>",
            iconAnchor:[6,6]
    });
    let activemrkr=L.marker([0,0],{
        icon:amicon, opacity:1, interactive:false
    }).addTo(map);

    let gmicon=L.divIcon({
            html:"<div style='position:absolute; width:20px;height:20px;border-radius:8px;border:1px solid white'></div>",
            iconAnchor:[10,10]
    })
    let ghostmrkr=L.marker([0,0],{
        icon:gmicon, opacity:0, interactive:true, draggable:true, zIndexOffset:5000,  bubblingMouseEvents:false
    }).addTo(map);

    function placeInfomrkr(c, send2rplan){
        if (typeof ghostmrkr.k !=="undefined"){
            let k=ghostmrkr.k;
            let pnt;

            if (!isNaN(c)){
                let dist=traj[k].dist*c
                let mind=Infinity;
                traj[k].seg.forEach(sg=>sg.pnts.forEach(p=>{
                    let d=Math.abs(p.dist-dist);
                    if (d<mind){mind=d; pnt=p}
                }));
            } else {
                let evlt=c.lat, evln=c.lng; let mind=Infinity;
                traj[k].seg.forEach(sg=>sg.pnts.forEach(p=>{
                    let d=(p.lat-evlt)*(p.lat-evlt)+(p.lng-evln)*(p.lng-evln);
                    if (d<mind){mind=d; pnt=p}
                }));
            }
            activemrkr.setLatLng(pnt);
            $("#active-mrkr").style.display="block";
            infomrkr.setLatLng(pnt);
            $("#mrkrLeft").innerHTML=
                "Model: "+traj[k].model+"<br>"+
                "Tot Dist: "+metrics.distance.conv[metric_dist].conversion(traj[k].dist).toFixed(2)+metric_dist+"<br>"+
                "Start: "+traj[k].starttimeStr.replace("T","<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")+"<br>"+
                "Duration: "+Math.round(traj[k].ete/min1)+"min";
            $("#mrkrRight").innerHTML=
                (pnt.wind?("Wind: "+metrics.wind.conv[metric_wind].conversion(pnt.wind).toFixed(2)+metric_wind+"<br>"):"")+
                (pnt.dir?("Dir: "+pnt.dir+"<br>"):"")+
                "Time: "+pnt.tStr.slice(11)+"<br>"+
                "Alt: "+pnt.altm+"m"+"<br>"+
                (pnt.nearestlvl?("Lvl: "+pnt.nearestlvl +"<br>"):"")+
                "Elev:"+pnt.elev+"m";

            $("#mrkr").style.display="block";
            store.set("timestamp",pnt.t);
            store.set("level",pnt.lvl=="1000h"?(startmodel=="iconEu"?"surface":"100m"):pnt.lvl);
            selectedPnt={lat:pnt.lat,lon:pnt.lng};       //must be {lat:,lon:}

            if (rp.isOpen  && send2rplan){
                rp.moveSliderLine(pnt.dist/traj[k].dist)
            }

            return pnt;
        }
    }

    ghostmrkr.on("drag",ev=>{
        placeInfomrkr(ev.latlng, true);
    });

    ghostmrkr.on("dragstart",e=>{
        bcast.fire('rqstClose','picker');
    });
    ghostmrkr.on("dragend",ev=>{
        ghostmrkr.setLatLng(activemrkr._latlng);

    });
    ghostmrkr.on("click",e=>{
    })

////picker elements for airspace

        let picker_asp=document.createElement("div");
        picker_asp.id="picker_asp";
        picker_asp.style.textHeight="100%"; picker_asp.style.fontSize="10px";

        pickerT.fillRightDiv(picker_asp);     pickerT.hideRightDiv();     //in case open before plugin mounted.

        pickerT.drag(e=>{
                pickerT.fillRightDiv(asp.findAsp(e));
        },350);

        picker.on('pickerOpened', e=>{
                picker_asp.innerHTML=asp.findAsp(e);
                pickerT.fillRightDiv(picker_asp);
        });

        picker.on('pickerMoved', e=>{
                pickerT.fillRightDiv(asp.findAsp(e));
        });

        picker.on('pickerClosed',e=>{
                asp.clearAsp();
        });


/////  function save .gpx
function saveGPX(){

    let colAr= ["DarkRed",  "DarkGreen", "DarkYellow", "DarkBlue", "DarkMagenta", "DarkCyan", "LightGray", "DarkGray",  "Red", "Green", "Yellow", "Blue", "Magenta", "Cyan", "White"];

    let sv=(content,fnm)=>{
        let a = document.createElement("a");
        let file=new Blob([content]);
        let url = URL.createObjectURL(file);
        a.href = url;
        a.download = fnm;
        document.body.appendChild(a);
        a.click();
    }

    let s=`<?xml version="1.0" encoding="utf-8"?><gpx creator="Windy.com/plugins --- windy-plugin-traj@${version}" version="1.1" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">`;
    traj.forEach(e=>{
        if (e.seg[0].pnts.length){  //check if any data,  else ignore
            let mn=0;
            let alt=Math.round(Number(e.alt)*0.3048);
            let garmincol=colAr[selLvls.findIndex(lv=>lv.lvl==e.lvl)];
            let topografix=selLvls[selLvls.findIndex(lv=>lv.lvl==e.lvl)].col.slice(1);
            s+=`
    <trk>
        <name>${e.lvl}</name>
        <desc>Model:${e.model},   Update time:${e.update},   Distance:${Math.round(e.dist)}m,   Time:${Math.round(e.ete/min1)}min,   Av speed:${Math.round((e.dist/10)/(e.ete/h1))/100}kph,   Alt: ${e.alt}ft </desc>
        <extensions>
            <gpxx:TrackExtension xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3">
                <gpxx:DisplayColor>${garmincol}</gpxx:DisplayColor>
            </gpxx:TrackExtension>
            <line xmlns="http://www.topografix.com/GPX/gpx_style/0/2">
                <color>${topografix}</color>
                <opacity>1</opacity>
            </line>
            <model>${e.model}</model>
            <update_time>${e.update}</update_time>
            <distance>${Math.round(e.dist)}</distance>
            <time_mins>${Math.round(e.ete/min1)}</time_mins>
            <av_speed_kmph>${Math.round((e.dist/10)/(e.ete/h1))/100}</av_speed_kmph>
            <level>${e.lvl}</level>
            <alt_ft>${e.alt}</alt_ft>
            <alt_m>${e.altm}</alt_m>
            <ascent>${e.calcBackward?e.descent:e.ascent}</ascent>
            <descent>${e.calcBackward?e.ascent:e.descent}</descent>
            <calc_backward>${e.calcBackward}</calc_backward>
        </extensions>
        <trkseg>`;
            e.seg.forEach(sg=>sg.pnts.forEach(pnt=>{
                        //let t=ej.t;
                            //let tm= new Date(pnt.t).toISOString().slice(0,-5)+"Z";
                    s+=
        `
            <trkpt lat="${pnt.lat}" lon="${pnt.lng}">
                <name>${e.lvl+"_"+mn}</name>
                <time>${pnt.tStr}</time>
                <ele>${pnt.altm}</ele>
            </trkpt> `;
                    mn+=pnt.sample;
            }));
            s+=
        `
        </trkseg>
    </trk>`;
        }//end if data in pnts
    });
    s+=`
</gpx>`;

    let tm= (new Date(traj[0].seg[0].t).toISOString()).slice(0,-5);
    sv(s,"trajectory__"+tm+".gpx");
}

//////////


	</script>
</plugin>
