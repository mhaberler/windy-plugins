<plugin>
    <div class="mobile-header" style="font-weight:bold">Trajectory Plugin</div>
    <div  class="plugin-content">
        <span id="desktop-title" style="font-size:14px; font-weight:bold;">Trajectory Plugin</span>  <br>  <br>
        &nbsp;-&nbsp;Place the picker. <br>
        &nbsp;-&nbsp;Select levels. <br>
        &nbsp;-&nbsp;Select trajectory duration. <br>
        &nbsp;-&nbsp;Select Ascent and Descent speed (m/s). <br>
        &nbsp;-&nbsp;If Ascent or Descent is set at 0, ascent or descent phases will be ignored. <br>
        &nbsp;-&nbsp;Set start time with Windy slider.   <br>
        &nbsp;-&nbsp;Start!    <br>
        &nbsp;-&nbsp;Current sample interval is 15 minutes,  ascent and descent phases at 1 min.  <br>
        &nbsp;-&nbsp;Duration slider will show progress. <br>
        &nbsp;-&nbsp;You can create many trajectories.   <br>
        &nbsp;-&nbsp;The trajectory can also be calculated in reverse,  to find starting point. <br>
        &nbsp;-&nbsp;Clicking a trajectory will switch the map to the correct timestamp and level,  and the marker will show the info at that point. <br>
        &nbsp;-&nbsp;If the picker is closed,  the trajctory marker will be used if visible,  when clicking "start" <br>
        &nbsp;-&nbsp;PluginDataLoader is used,  will use the model selected (ECMWF, GFS or ICON).<br>  <br>
        <div id="select-colors" style="display:inline-block">
            <span style="font-size:15px; font-weight:bold;">Select Colors:</span><br> <br>
        </div>
        <div id="colpick" style="position:relative;display:inline-block; vertical-align:top;"></div>
        <div style="font-size:10px;margin-top:15px">Settings will be stored in localStorage on your browser.</div>
    </div>

<script>
    let version= "0.4.5";

	import map from '@windy/map';
	import store from '@windy/store';
	import bcast from '@windy/broadcast';
    import picker from '@windy/picker';
    import $ from '@windy/$';
    import rs from '@windy/rootScope';
    import utils from '@windy/utils';
    import ib from './infobox.mjs';
    import pluginDataLoader from '@windy/pluginDataLoader'
    import metrics from '@windy/metrics';
    import favs from '@windy/favs';

    const load = pluginDataLoader({
		key: 'tqBdvHJjtNrGq4TrFzt9D5NDz9fIZSC8'
		, plugin: 'windy-plugin-da'
	});

    let traj=[];
    let currentlvl;
    let ascent=localStorage.getItem("ascent");
    if (!ascent) ascent=0;
    let descent=localStorage.getItem("descent");
    if (!descent) descent=0;
    let durmin=localStorage.getItem("durmin");
    if (!durmin) durmin=0;

    let pntAlt,pntAltm;

    let reftime;
    let h1=60*60*1000;  let h3=3*h1;  let min1=60*1000;  let d1=24*60*60*1000;   let d6=6*24*60*60*1000;
    let sample=15;
    var sampleAscDes=1;
    //let ts;            //timestamp   no longer used
    let tn=Date.now(); //time now
    let startlvl, startmodel;
    let running=false;
    let backw=false;
    let metric_wind=store.get("metric_wind");
    let metric_dist=metricDist(metric_wind);
    let selectedPnt=false;
    store.on("metric_wind",w=>{
        metric_wind=w;
        metric_dist=metricDist(w);
    });

    let fvs=favs.getAll();
    let fvsDivs=[];

    let pickerOpen=false;
    bcast.fire('rqstClose','picker');
    picker.on("pickerClosed",()=>{pickerOpen=false});
    picker.on("pickerOpened",()=>{pickerOpen=true});

    function metricDist(mw){
        switch (mw){
            case "m/s":  case "km/h":  return "km";  break;
            case "mph":   return "mi";  break;
            default: return  "NM";
        }
    }

    let levels=store.get("availLevels");
    let selLvls;
    try{
        selLvls=JSON.parse(localStorage.getItem("selLvls"));
    } catch (e){console.log("error localStorage, load default values");}

    if (!selLvls  ||  selLvls[0].col.slice(0,2)=="rg")
    selLvls=[ {lvl: "surface", alt:30, altm:10,    sel: false,
                //col:"DarkRed"}
                //col:"rgba(205, 92, 92, 1)"}
                col: "#CD5C5C"}
        , {lvl: "1000h", alt:330, altm:100,  sel: false,
                //col: "DarkGreen"}
                //col:"rgba(255, 160, 122, 1) "}
                col:"#FFA07A"}
        , {lvl: "950h", alt:2000, altm: 600, sel: false,
                //col: "DarkYellow"}
                //col:"rgba(255, 0, 0, 1)"}
                col: "#FF0000"}
        , {lvl: "925h", alt:2500, altm: 750, sel: false,
                //col: "DarkBlue"}
                //col:"rgba(255, 192, 203, 1)   "}
                col:"#FFC0CB"}
        , {lvl: "900h", alt:3000, altm:900, sel: false,
                //col: "DarkMagenta"}
                //col:"rgba(255, 105, 180, 1) "}
                col:"#FF69B4"}
        , {lvl: "850h", alt:5000,  altm:1500, sel: false,
                //col: "DarkCyan"}
                //col:"rgba(255, 160, 122, 1)"}
                col:"#FFA07A"}
        , {lvl: "800h", alt:6400,  altm:2000, sel: false,
                //col: "Red"}
                //col:"rgba(255, 165, 0, 1)"}
                col:"#FFA500"}
        , {lvl: "700h", alt:10000, altm:3000, sel: false,
                //col: "Green"}
                //col:"rgba(255, 255, 0, 1)"}
                col:"#FFFF00"}
        , {lvl: "600h", alt:14000, altm:4200, sel: false,
                //col: "Yellow"}
                //col:"rgba(255, 228, 181, 1)"}
                col:"#FFE4B5"}
        , {lvl: "500h", alt:18000, altm:5500,sel: false,
                //col: "Blue"}
                //col:"rgba(255, 0, 255, 1)"}
                col:"#FF00FF"}
        , {lvl: "400h", alt:24000, altm:7000, sel: false,
                //col: "Magenta"}
                //col:"rgba(173, 255, 47, 1)"}
                col:"#ADFF2F"}
        , {lvl: "300h", alt:30000, altm:9000, sel: false,
                //col: "Cyan"}
                //col:"rgba(0, 255, 255, 1)"}
                col:"#00FFFF"}
        , {lvl: "200h", alt:39000, altm:11700, sel: false,
                //col: "LightGray"}
                //col:"rgba(135, 206, 250, 1)" }
                col:"#87CEFA"}
        , {lvl: "150h", alt:45000, altm:13500, sel: false,
                //col: "White"}
                //col:"rgba(255, 255, 255, 1)"}
                col:"#FFFFFF"}
    ];

    ////message div
    let msgdiv=document.createElement("div");
    msgdiv.classList.add("msg-div");

    ////Box at bottom left
    ib(`<div style="box-sizing-border-box;  padding:5px 5px 3px 5px; display:inline-block; pointer-events:auto; border-radius:7px; background-color:rgba(0,0,0,0.5); border:  1px solid rgba(0,0,0,0.6); font-size:13px;">
            <div id="select-levels" style="width:230px; font-size:12px; margin-bottom:8px;"><div style="margin-bottom:5px;font-size:13px">Select Levels</div></div>

            <div style="display:inline-block">
                <div style="margin:0px;position:relative; width:113px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                    <input id="asc_range" step="0.1" style="left:3px; height:20px; top:-1px; position:absolute;  width:107px; z-index:999; opacity:0;" type="range"  max="8" >
                    <div id="thumb_asc" class="thumb"></div>
                </div>
                <div  style="width:113px;   ">Ascent: <span id="asc_span"></span></div>
            </div>
            <div style="display:inline-block">
                <div style="margin:0px;position:relative;  width:113px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                    <input id="des_range"  step="0.1" style="left:3px; height:20px; top:-1px; position:absolute;  width:107px; z-index:999; opacity:0;" type="range"  max="8" >
                    <div id="thumb_des" class="thumb"></div>
                </div>
                <div  style="width:113px;   ">Descent: <span id="des_span"></span></div>
            </div>

            <div style="position:relative; width:230px; height:20px;  border-radius:8px; border:1px solid rgba(255,255,255,0.5);">
                <input id="dur_range" style="left:3px; height:20px; top:-1px; position:absolute;  width:224px; z-index:999; opacity:0;" type="range"  max="96" >
                <div id="thumb1" class="thumb"></div>
                <div id="progress-thumb" class="thumb" style="opacity:0" ></div>
            </div>
            <div  style="  width:220px; ">Duration: <span id="duration"></span>&nbsp;&nbsp;<span style="font-size:9px">Running <span  id="traj-direction">${backw?"backward - find start":"forward - find end"}</span></span></div>

            <div id="open-left-pane" class="start-buttons">
                Menu
            </div>
            <div id="save-gpx" class="start-buttons">
                Save
            </div>
            <div id="clear-trajs" class="start-buttons">
                Clear
            </div>
            <div id="backw" class="start-buttons" >
                ${backw?"Forw":"Back"}
            </div>
            <div id="start-IP" class="start-buttons">
                Start
            </div>

        </div>
        <div id="display-fav-div"  class="iconfont">k</div>
        <div id="fav-div" style="display:none"><span style="font-weight:bold">Click to find fav:</span><br></div>
        `,
        "open-left-pane", "windy-plugin-traj", this
    );
    function showMsg(m){
        msgdiv.innerHTML=m;
        document.getElementById("map-container").appendChild(msgdiv);
        setTimeout(()=>msgdiv.remove(), 2000);
    }
    $("#start-IP").addEventListener("click",()=>{
        startmodel=store.get("product");
        let startpos=pickerOpen?picker.getParams():(selectedPnt?selectedPnt:false);
        if (startpos && !running && (startmodel=="ecmwf" ||  startmodel=="gfs" || startmodel=="iconEu"))  {
            if (backw && (store.get("timestamp")+h1/2)<tn+durmin*min1){
                showMsg(`Backward trajectory<br>Move time forward.`);
            } else {
                drawTraj(startpos);
                running=true;
                $("#start-IP").innerHTML="Stop";
            }
        }  else if (running){
            running=false;
        }  else if (!startpos) {
            showMsg(`Place Picker`);
        }  else {
            showmsg(`Model (${startmodel}) not supported`);
        }
    });
    $("#clear-trajs").addEventListener("click",()=>{
        traj.forEach(e=>e.seg.forEach(l=>{
            l.line.remove();
            l.ghostline.remove();
            l.pnts.forEach(m=>{if(m.mrkr)m.mrkr.remove()});
        }));
        traj=[];
    });
    $("#backw").addEventListener("click",e=>{           ////allow backward traj
        backw=!backw;
        let tmp=ascent; ascent=descent; descent=tmp;
        e.target.innerHTML=backw?"Forw":"Back";
        $("#traj-direction").innerHTML=backw?    "<span style='font-weight:bold'>backward</span> - find start":    "<span style='font-weight:bold'>forward</span> - find end";
    });
    $("#save-gpx").addEventListener("click",()=>{
        saveGPX();
    });
    $("#display-fav-div").addEventListener("click",()=>{
        if ($("#fav-div").style.display=="none"){
            $("#fav-div").style.display="inline-block";
            $("#display-fav-div").style.opacity=1;
        }  else {
            $("#fav-div").style.display="none";
            $("#display-fav-div").style.opacity=0.4;
        }
    })
    function setDur(v){
        $('#thumb1').style.left=210*v/96+'px';
        durmin=v*15;
        $('#duration').innerHTML=('0'+Math.floor(durmin/60)).slice(-2)+':'+('0'+ durmin%60).slice(-2);
        localStorage.setItem("durmin",durmin/15);
    }
    function setAsc(v){
        $('#thumb_asc').style.left=93*v/8+'px';
        ascent=v;
        if (ascent==0) $('#asc_span').innerHTML="None";
        else $('#asc_span').innerHTML=ascent+" m/s";
        localStorage.setItem("ascent",ascent);
    }
    function setDes(v){
        $('#thumb_des').style.left=93*v/8+'px';
        descent=v;
        if (descent==0) $('#des_span').innerHTML="None";
        else $('#des_span').innerHTML=descent+" m/s";
        localStorage.setItem("descent",descent);
    }
    $("#dur_range").addEventListener("input",e=>setDur(e.target.value));
    $("#asc_range").addEventListener("input",e=>setAsc(e.target.value));
    $("#des_range").addEventListener("input",e=>setDes(e.target.value));
    setDur(durmin); setAsc(ascent);  setDes(descent);

    if (rs.isMobile)$("#desktop-title").style.display="none";
    if (rs.isTablet){$("#logo").style.left="100%"; $("#logo").style.marginLeft="-150px";}

    selLvls.forEach((e,i)=>{
        e.div=document.createElement("div");
        e.div.innerHTML=e.lvl+" "+(e.alt<10000?(e.alt+"ft"):(e.alt/100+"FL"));
        e.div.style.display="inline-block";  e.div.style.width="115px";
        if (e.sel){
            e.div.style.opacity=1; e.div.style.color=e.col;
        } else {
            e.div.style.opacity=0.5; e.div.style.color="white";
        }
        e.div.addEventListener("click",el=>{
            if(e.sel){
                e.div.style.opacity=0.5;
                e.sel=false;
                e.div.style.color="white";
            } else {
                e.div.style.opacity=1;
                e.div.style.color=e.col;
                e.sel=true;
            }
            localStorage.setItem("selLvls",JSON.stringify(selLvls));
        });

        let lbl=document.createElement("div");  lbl.innerHTML="<span style='display:inline-block;width:50px'>"+e.lvl+"</span>";
        $("#select-colors").appendChild(lbl);
        e.input=document.createElement("input");
        e.input.type="text";
        e.input.value=e.col;
        e.input.dataset.i=i;
        e.input.classList.add("trajColor");
        lbl.appendChild(e.input);
        e.input.onfocus=()=>{
            setTimeout(()=>{
                $("#colpick").firstElementChild.style.transition="all 0.3s";
                $("#colpick").firstElementChild.style.left="3px";
                $("#colpick").firstElementChild.style.top="25px";
            },100);
        }
        e.input.onkeydown=e=>e.stopPropagation();
        e.input.onchange=e=>{e.target.blur();e.target.focus()}
        $("#select-levels").appendChild(e.div);
        if (i%2==1){
            let br=document.createElement("br");
            $("#select-levels").appendChild(br);
        }
    })

    ////favourites
    for (let f in fvs){
        let d=document.createElement("div");
        d.innerHTML=fvs[f].name;
        d.style.padding="3px";
        d.style.cursor="pointer";
        d.addEventListener("click",e=>{
            map.setView(fvs[f]);
            setTimeout(()=>bcast.fire('rqstOpen','picker',fvs[f]),2000);
        })
        fvsDivs.push(d);
        $("#fav-div").appendChild(d);
    }

    ////color picker
    function cb(col,b,c){
        let i=c.input.dataset.i;
        selLvls[i].col=c.input.value;
        if(selLvls[i].sel) selLvls[i].div.style.color=selLvls[i].col;
        c.input.style.color=col.alpha<0.4?"black":(col.RGBLuminance<0.3?"white":"black");
        localStorage.setItem("selLvls",JSON.stringify(selLvls));
    }

    setTimeout(()=>{
        window.jsColorPicker("input.trajColor",{
            customBG:"#222",
            readOnly:false,
            size:1,
            appendTo: $("#colpick"),
            init:function(o,e){
                o.style.backgroundColor=o.value,
                o.style.color=e.alpha<0.4?"black":(e.RGBLuminance<0.3?"white":"black");
            },
            displayCallback:cb
        });
    },500);

    ////other settings:


    ////grab reftime
    function getRefTime(model){
        let cntr=map.getCenter();   cntr.lon=cntr.lng;    cntr.model=model;
        load("forecast",cntr).then(data=>{
            reftime=new Date(data.data.header.refTime).getTime();
            return reftime;
        });
    }
    startmodel=store.get("product");    getRefTime(startmodel);

    //function time2path(t){            ////no longer using the path
    //    hrsInt=(startmodel=="ecmwf" && t-reftime>d6)?6:3;
    //    let tmshift=new Date(t+hrsInt*30*60*1000);
    //    return tmshift.getUTCFullYear()+"/"+("0"+(tmshift.getUTCMonth()+1)).slice(-2)+"/"+("0"+tmshift.getUTCDate()).slice(-2)+"/"+("0"+Math.floor(tmshift.getUTCHours()/hrsInt)*hrsInt).slice(-2);
    //}

    function time2index(t){
        let i= Math.floor((t-reftime-h3/2)/h3);
        if (startmodel=="ecmwf"  &&  i>47) i=47+Math.floor((i-46)/2);
        return i;
    }
    function time2midtime(t){
        let h=(startmodel=="ecmwf" && t-reftime>d6+h3/2)?h3*2:h3;
        return Math.floor(((t-reftime)+h/2)/h)*h;
    }

    ////highlight time segment   (3 or 6 hours if ecmwf>6 days after reftime)
    store.on("timestamp",e=>{
            let midtime=time2midtime(e);
            traj.forEach(e=>e.seg.forEach(l=>{
                if (l.midtime==midtime)l.line.setStyle({weight:4});
                else l.line.setStyle({weight:2});
            }));
    });

    store.on("level",lvl=>{
        selLvls.forEach(e=>{
            e.div.style.fontWeight= e.lvl==lvl?"bold":"normal";
        })
        if(lvl=="100m")lvl="1000h";
        currentlvl=lvl;
        traj.forEach(e=>e.seg.forEach(l=>{
            if (l.lvl==lvl)l.line.setStyle({opacity:1});
            else l.line.setStyle({opacity:0.4});
        }));
    });

    store.on("product",model=>{
        startmodel=model;
    });

    function drawTraj(cstart,startt=false,lvli=-1){

        let c=cstart;
        console.log(c);
        pntAltm=-9999;

        if (!startt){
            startt= Math.round((store.get("timestamp"))/(60*min1))*60*min1;
            startlvl=store.get("level");
        }
        console.log(startt);

        $('#progress-thumb').style.opacity=0.4;

        let nextLvl=(lvli)=>{
            for (lvli++ ;lvli<selLvls.length&&!selLvls[lvli].sel ;lvli++);
            return lvli<selLvls.length?lvli:-1;
        }

        if (lvli<0){
            lvli=nextLvl(lvli);
            if (lvli<0) return;
        }
        let lvl=selLvls[lvli].lvl;
        let col=selLvls[lvli].col;

        if (lvl=="250h"){lvl="300h"; store.set("level",lvl)}

        traj.forEach(e=>e.seg.forEach(l=>l.line.setStyle({opacity:0.4})));
        let k=traj.push({
            starttimeStr:new Date(startt).toISOString().slice(0,-5)+"Z",
            dist:0,
            ete:0,
            lvl:lvl,
            lvli:lvli,
            alt:selLvls[lvli].alt,
            altm:selLvls[lvli].altm,
            model:startmodel,
            ascent: ascent,
            descent: descent,
            calcBackward: backw,
            seg:[]
        })-1;

        let previ=-99;
        let j=-1;
        let n=0;

        let fetchData=(c,t,lvl)=>{
            store.set("timestamp",t);

            let fetchPoint=c=>{
                c.model=startmodel;
                load("forecast",c).then(data=>{
                    console.log("forecast", data.data.header.refTime);
                })
                load('airData',c).then(data=>{

                    console.log(data);

                    console.log(data.data.data.hours[0]);
                    reftime=new Date(data.data.header.refTime).getTime();
                    console.log("air",data.data.header.refTime);

                    let i=time2index(t);  //i refers to index in data array,  3 hourly intervals
                                            //the reftime may change and consequently index value may change.
                    console.log("index",i);

                    if (i!=previ){  //add segment with polyline
                        j++;
                        traj[k].seg[j]={
                            line:L.polyline([c], {color: col, weight:2, opacity:1, interactive:false, smoothFactor:0.5}).addTo(map),
                            ghostline:L.polyline([c], {color: "white", opacity:0, weight:13, smoothFactor:0.1, interactive:true, bubblingMouseEvents:false}).addTo(map),
                            lvl:lvl,  alt:selLvls[lvli].alt, t:t, midtime:time2midtime(t),  j:j, k:k,  pnts:[]
                        };
                        let ll=traj[k].seg[j];
                        ll.ghostline.on("click",ev=>{
                            ghostmrkr.k=k;
                            let nearestPnt=placeInfomrkr(ev.latlng);
                            store.set("timestamp",nearestPnt.t);
                            ghostmrkr.setLatLng(nearestPnt);

                            //selpth=ll.pth;
                            store.set("level",ll.lvl=="1000h"?"100m":ll.lvl);
                            selLvls.forEach(e=>{
                                if(ll.lvl==e.lvl)e.div.style.fontWeight="bold"; else e.div.style.fontWeight="normal";
                            });
                            traj.forEach(e=>e.seg.forEach(l=>{
                                if (ll.k==l.k){
                                    if (ll.j==l.j) l.line.setStyle({weight:4, opacity:1});
                                    else l.line.setStyle({weight:2, opacity:0.9});
                                }else l.line.setStyle({weight:2,opacity:0.4});
                            }));
                        });
                        previ=i;
                    }

                    let endTraj=false;
                    let smpl=sampleAscDes;
                    let pntElev=data.data.header.elevation

                    //look for phase and determine next alt.  With start of traj pntAltm=-9999
                    if (traj[k].lvl=="surface"){
                        pntAltm=pntElev;
                        smpl=sample;
                        if (t>startt+durmin*min1 || (backw && t<startt-durmin*min1)) endTraj=true;               ////allow backward traj
                    }  else {
                        if (pntAltm==-9999){ //start
                            if (ascent==0 || pntElev>=traj[k].altm){
                                smpl=sample;
                                pntAltm=(pntElev>traj[k].altm)?pntElev:traj[k].altm;
                            } else {
                                pntAltm=pntElev;
                            }
                        } else if (t>=startt+durmin*min1 || (backw && t<=startt-durmin*min1)){    // duration hit,  start descent ////allow backward traj
                            if (descent==0 || (pntAltm<=pntElev+10)) endTraj=true;  //stop if BGL or none descent selected
                            else pntAltm-=descent*smpl*60;
                        } else if (pntAltm<traj[k].altm){     //still rising.
                            pntAltm+=ascent*smpl*60;
                            if (pntAltm>=traj[k].altm){       //now  altitude reached
                                pntAltm=traj[k].altm;
                                smpl=backw?(t/min1)%sample : (sample-((t/min1)%sample)); //find next timepoint where (time in min % sample)==0.  Makes it easier to make hour markers.
                            }
                        } else{
                            smpl=sample;
                            if (pntElev>traj[k].altm) pntAltm=pntElev;
                        }
                    }

                    console.log("Alt(m):",pntAltm, "Elev",pntElev);

                    traj[k].seg[j].pnts.push({
                            lat:c.lat,lng:c.lon,
                            t:t,
                            tStr: new Date(t).toISOString().slice(0,-5)+"Z",
                            elev:pntElev,
                            alt:pntAlt,
                            altm:pntAltm,
                            //lvl:w.nearestlvl,
                            sample:smpl
                    });
                    ////hour markers
                    if (t%h1==0){
                            let tm=t;
                            traj[k].seg[j].pnts[traj[k].seg[j].pnts.length-1].mrkr=
                                 L.circleMarker(c,{radius:1, color:"black", weight:4,  opacity:0.8, interactive:false})
                                    .addTo(map)
                    }

                    if (!endTraj) {
                        n+=smpl/15;
                        $('#progress-thumb').style.left=210*n/96+'px';

                        let getWind=(lvli,i)=>{    //let o=utils.wind2obj([u,v,0]);  utils of windy rounds to 10,  thus do not use
                                let u=data.data.data["wind_u-"+selLvls[lvli].lvl][i];
                                let v=data.data.data["wind_v-"+selLvls[lvli].lvl][i];
                                return{
                                    wind:Math.sqrt(u*u+v*v),
                                    dirto:Math.floor(180*Math.atan2(u,v)/Math.PI)
                                }
                        }

                        let topi,btmi, vrtio;
                        if (pntAltm>pntElev){
                            for (topi=1; topi<selLvls.length-1 && selLvls[topi].altm<=pntAltm; topi++);
                            let top=selLvls[topi].altm;
                            btmi=topi-1;
                            let btm=selLvls[btmi].altm;
                            if (selLvls[btmi].altm<pntElev){btmi=0; btm=pntElev;}
                            vrtio= (pntAltm-btm)/(top-btm);
                            if (vrtio>=1){btmi=topi; vrtio=0;} //if the pntAltm>topmost level,  then make the topmost index btmi and vrtio 0,  so correctly handled by verticalIP.
                        } else {
                            btmi=lvli;vrtio=0;
                        }

                        ////vertical linear interpolation on altitude in meter.  pressure  better???
                        let verticalIP=(vrtio,btmi,topi,i)=>{
                            if (vrtio==0 || typeof topi==="undefined"){
                                let w=getWind(btmi,i);
                                w.nearestlvl=selLvls[btmi].lvl;
                                return w;
                            } else {
                                let wb=getWind(btmi,i);
                                let wt=getWind(topi,i);
                                return{
                                    wind: wb.wind+(wt.wind-wb.wind)*vrtio,
                                    dirto: wb.dirto+(wt.dirto-wb.dirto)*vrtio,
                                    nearestlvl:selLvls[vrtio<0.5?btmi:topi].lvl
                                }
                            }
                        }
                        let w1=verticalIP(vrtio,btmi,topi,i);

                        ///interpolate time
                        let w,w2={};
                        let midt=data.data.data.hours[i];
                        let deltat=t-midt;
                        if ((deltat<=0 && i>0)|| (deltat>=0 && i<data.data.data.hours.length-1)){
                            let i2=deltat<0?i-1:i+1;
                            w2=verticalIP(vrtio,btmi,topi,i2);
                            let trtio=Math.abs(deltat/(data.data.data.hours[i]-data.data.data.hours[i2]));
                            let deltadir=(w2.dirto-w1.dirto);
                            if (deltadir>180)deltadir-=360; else if (deltadir<-180)deltadir+=360;
                            w={wind: w1.wind+(w2.wind-w1.wind)*trtio ,dirto: w1.dirto+deltadir*trtio ,nearestlvl:w1.nearestlvl}
                        }  else {
                            w=w1;
                        }

                        let dirfrom=(w.dirto+180)%360;
                        let d=smpl*60*w.wind;

                        traj[k].dist+=d;
                        traj[k].ete+=smpl*min1;
                        if(!traj[k].update) traj[k].update=data.data.header.update;

                         /////////calculate next point,  thx to Chris Veness (github)
                        var ad=d/6371000;//angular distance
                        var rad=Math.PI/180;
                        var brng=(backw?dirfrom:w.dirto)*rad;           ////allow backward traj
                        var lat1=c.lat*rad;
                        var lon1=c.lon*rad;
                        var lat2 = Math.asin(Math.sin(lat1)*Math.cos(ad) + Math.cos(lat1)*Math.sin(ad)*Math.cos(brng))   ;
                        var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(ad)*Math.cos(lat1), Math.cos(ad)-Math.sin(lat1)*Math.sin(lat2))   ;
                        lat2/=rad; lon2/=rad;
                        ///////////

                        traj[k].seg[j].line.addLatLng([lat2,lon2]);
                        traj[k].seg[j].ghostline.addLatLng([lat2,lon2]);

                        Object.assign(traj[k].seg[j].pnts[traj[k].seg[j].pnts.length-1],{
                            d:d,
                            wind:w.wind,
                            dir:Math.round(dirfrom),
                            nearestlvl:w.nearestlvl
                        });

                        t+=smpl*min1 * (backw?-1:1);              ////allow backward traj
                        if (t>reftime+d1*10 || (t>reftime+d1*5 && startmodel=="iconEu") || t<reftime+(h3/2)) {
                            endTraj=true;
                        }
                    }

                    if (endTraj || !running){
                        store.set("timestamp",startt);
                        $('#progress-thumb').style.opacity=0;
                        lvli=nextLvl(lvli);
                        if (lvli>=0 && running){
                            drawTraj(cstart,startt,lvli);
                        }  else {
                            running=false;
                            $("#start-IP").innerHTML="Start";
                            console.log("This is the array of polylines and other properties:",traj);
                            store.set("level",startlvl);
                        }
                    } else setTimeout(fetchData,740,{lat:lat2,lon:lon2},t,lvl);
                }).catch(er=>{
                    console.log("usually  blocked by server CORS error - too busy???",   er);  /////usually  blocked by server CORS error - too busy???
                    if (er==0){
                        msgdiv.innerHTML=`Server not responding... trying...`;
                        document.getElementById("map-container").appendChild(msgdiv);
                        setTimeout(()=>msgdiv.remove(), 2000);
                    }
                    setTimeout(fetchPoint,3000,c);
                });
            }
            fetchPoint(c);
        }
        if(lvl){
            store.set("level",lvl=="1000h"?"100m":lvl);
            fetchData(c,startt,lvl);
        }
    }

///////Info marker
    let infoicon=L.divIcon({html:
        `<div id="mrkr" style="display:none; height:100px; width:120px; height:25px; border:0px solid white; outline-style:none; position:absolute;   font-family:arial; color:white;  text-shadow: 1px 1px 1px rgba(0,0,0,0.4); background-color:transparent; white-space:nowrap;">
            <div id="close-info-mrkr"  class="closing-x" style="display:block; margin:3px; font-size:15px; top:0px; right:0px;"></div>`+
            `<div style="display:block; position:absolute; left:-15px; top:0px; width:30px; height:140px;">
                <div style="position:absolute;left:15px;top:3px;border-left:2px solid rgba(0,0,0,0.8); height:115px;"></div>
                <div style="display:none; position:absolute; left:12px; top:calc(120.5px); background-color:white; width:8px; height:8px; border-radius:4px;"></div>
            </div>`+
            //`<div id="posname" class="picker-transparent"  style="position:absolute; top:-20px; left:0px; transform:translateX(-50%); font-weight:bold; "></div>`+
            `<div id="mrkrLeft" style="pointer-events: none; position:absolute; font-size:11px; line-height:110%;  top:0px;  position:absolute; padding:3px;  border-radius:5px 0px 0px 5px;  right:120px; opacity:1; background-color:rgba(0,0,0,0.7);">  </div>`+
            `<div id="mrkrRight" style="pointer-events: none; line-height:110%; width:100%; font-size:11px; position:absolute; padding:3px;  border-radius:0px 5px 5px 0px;  left:0px; opacity:1; background-color:rgba(0,0,0,0.8);"></div>
        </div>`
    ,iconAnchor:[0,125]});
    let infomrkr = L.marker([0,0],{icon:infoicon, interactive:true, bubblingMouseEvents:false, opacity:1,  zIndexOffset:4700});
    infomrkr.addTo(map);
    infomrkr._icon.style.outlineStyle="none";
    L.DomEvent.on( $('#close-info-mrkr'), 'click', e=>{
        //use Leaflet addListener and not usual addEventListener to allow stop propagtion of the click, which will then open the picker
        L.DomEvent.stopPropagation(e);
        //infomrkr.setOpacity(0);   Do not use setOpacity,  mrkr hidden but still clickable
        $("#mrkr").style.display="none";
        $("#active-mrkr").style.display="none";
        selectedPnt=false;
    });

    let amicon=L.divIcon({
            html:"<div id='active-mrkr' style='position:absolute;width:12px;height:12px;border-radius:5px;border:1px solid white'></div>",
            iconAnchor:[6,6]
    });
    let activemrkr=L.marker([0,0],{
        icon:amicon, opacity:1, interactive:false
    }).addTo(map);

    let gmicon=L.divIcon({
            html:"<div style='position:absolute; width:20px;height:20px;border-radius:8px;border:1px solid white'></div>",
            iconAnchor:[10,10]
    })
    let ghostmrkr=L.marker([0,0],{
        icon:gmicon, opacity:0, interactive:true, draggable:true, zIndexOffset:5000,  bubblingMouseEvents:false
    }).addTo(map);

    function placeInfomrkr(c){
        if (typeof ghostmrkr.k!=="undefined"){
            let k=ghostmrkr.k;
            let pnt;
            let evlt=c.lat, evln=c.lng; let mind=Infinity;
            traj[k].seg.forEach(sg=>sg.pnts.forEach(p=>{
                let d=(p.lat-evlt)*(p.lat-evlt)+(p.lng-evln)*(p.lng-evln);
                if (d<mind){mind=d; pnt=p}
            }));
            activemrkr.setLatLng(pnt);
            $("#active-mrkr").style.display="block";
            infomrkr.setLatLng(pnt);
            $("#mrkrLeft").innerHTML=
                "Model: "+traj[k].model+"<br>"+
                "Tot Dist: "+metrics.distance.conv[metric_dist].conversion(traj[k].dist).toFixed(2)+metric_dist+"<br>"+
                "Start: "+traj[k].starttimeStr.replace("T","<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")+"<br>"+
                "Duration: "+Math.round(traj[k].ete/min1)+"min";
            $("#mrkrRight").innerHTML=
                (pnt.wind?("Wind: "+metrics.wind.conv[metric_wind].conversion(pnt.wind).toFixed(2)+metric_wind+"<br>"):"")+
                (pnt.dir?("Dir: "+pnt.dir+"<br>"):"")+
                "Time: "+pnt.tStr.slice(11)+"<br>"+
                "Alt: "+pnt.altm+"m"+"<br>"+
                (pnt.nearestlvl?("Lvl: "+pnt.nearestlvl +"<br>"):"")+
                "Elev: "+pnt.elev+"m";
            $("#mrkr").style.display="block";
            store.set("timestamp",pnt.t);
            store.set("level",pnt.lvl=="1000h"?"100m":pnt.lvl);
            selectedPnt={lat:pnt.lat,lon:pnt.lng};       //must be {lat:,lon:}
            return pnt;
        }
    }

    ghostmrkr.on("drag",ev=>{
        placeInfomrkr(ev.latlng);
    });

    ghostmrkr.on("dragstart",e=>{
        bcast.fire('rqstClose','picker');
    });
    ghostmrkr.on("dragend",ev=>{
        ghostmrkr.setLatLng(activemrkr._latlng);

    });
    ghostmrkr.on("click",e=>{
    })

/////  function save .gpx
function saveGPX(){

    let colAr= ["DarkRed",  "DarkGreen", "DarkYellow", "DarkBlue", "DarkMagenta", "DarkCyan", "LightGray", "DarkGray",  "Red", "Green", "Yellow", "Blue", "Magenta", "Cyan", "White"];

    let sv=(content,fnm)=>{
        let a = document.createElement("a");
        let file=new Blob([content]);
        let url = URL.createObjectURL(file);
        a.href = url;
        a.download = fnm;
        document.body.appendChild(a);
        a.click();
    }

    let s=`<?xml version="1.0" encoding="utf-8"?><gpx creator="Windy.com/plugins --- windy-plugin-traj@${version}" version="1.1" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">`;
    traj.forEach(e=>{
        if (e.seg[0].pnts.length){  //check if any data,  else ignore
            let mn=0;
            let alt=Math.round(Number(e.alt)*0.3048);
            let garmincol=colAr[selLvls.findIndex(lv=>lv.lvl==e.lvl)];
            let topografix=selLvls[selLvls.findIndex(lv=>lv.lvl==e.lvl)].col.slice(1);
            s+=`
    <trk>
        <name>${e.lvl}</name>
        <desc>Model:${e.model},   Update time:${e.update},   Distance:${Math.round(e.dist)}m,   Time:${Math.round(e.ete/min1)}min,   Av speed:${Math.round((e.dist/10)/(e.ete/h1))/100}kph,   Alt: ${e.alt}ft </desc>
        <extensions>
            <gpxx:TrackExtension xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3">
                <gpxx:DisplayColor>${garmincol}</gpxx:DisplayColor>
            </gpxx:TrackExtension>
            <line xmlns="http://www.topografix.com/GPX/gpx_style/0/2">
                <color>${topografix}</color>
                <opacity>1</opacity>
            </line>
            <model>${e.model}</model>
            <update_time>${e.update}</update_time>
            <distance>${Math.round(e.dist)}</distance>
            <time_mins>${Math.round(e.ete/min1)}</time_mins>
            <av_speed_kph>${Math.round((e.dist/10)/(e.ete/h1))/100}</av_speed_kph>
            <level>${e.lvl}</level>
            <alt_ft>${e.alt}</alt_ft>
            <alt_m>${e.altm}</alt_m>
            <ascent>${e.calcBackward?e.descent:e.ascent}</ascent>
            <descent>${e.calcBackward?e.ascent:e.descent}</descent>
            <calc_backward>${e.calcBackward}</calc_backward>
        </extensions>
        <trkseg>`;
            e.seg.forEach(sg=>sg.pnts.forEach(pnt=>{
                        //let t=ej.t;
                            //let tm= new Date(pnt.t).toISOString().slice(0,-5)+"Z";
                    s+=
        `
            <trkpt lat="${pnt.lat}" lon="${pnt.lng}">
                <name>${e.lvl+"_"+mn}</name>
                <time>${pnt.tStr}</time>
                <ele>${pnt.altm}</ele>
            </trkpt> `;
                    mn+=pnt.sample;
            }));
            s+=
        `
        </trkseg>
    </trk>`;
        }//end if data in pnts
    });
    s+=`
</gpx>`;

    let tm= (new Date(traj[0].seg[0].t).toISOString()).slice(0,-5);
    sv(s,"trajectory__"+tm+".gpx");
}

//////////


	</script>
</plugin>
